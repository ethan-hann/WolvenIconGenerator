using AetherUtils.Core.Logging;
using System.Diagnostics;

namespace WIG.Lib.Utility;

/// <summary>
/// Handles running the low-level CLI commands for WolvenKit and generate-inkatlas.exe. Has events for streaming output and error messages generated by the CLI.
/// </summary>
internal class Cli
{
    private readonly string _executablePath;
    private CancellationToken _cancellationToken;

    public event EventHandler<string?>? OutputChanged;
    public event EventHandler<string?>? ErrorChanged;

    public Cli(string executablePath, CancellationToken cancellationToken)
    {
        _executablePath = executablePath;
        _cancellationToken = cancellationToken;
    }

    #region generate-inkatlas.exe
    /// <summary>
    /// Generate an .inkatlas file from a folder of images.
    /// </summary>
    /// <param name="iconFolderPath">The path to the folder containing the .png files.</param>
    /// <param name="outputFolderPath">The output path the final .inkatlas.json file should be saved.</param>
    /// <param name="atlasName">The name of the atlas to generate.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task GenerateInkAtlasJsonAsync(string iconFolderPath, string outputFolderPath, string atlasName)
    {
        var arguments = $"\"{iconFolderPath}\" \"{outputFolderPath}\" \"{atlasName}\"";
        await ExecuteCommandAsync(arguments, _cancellationToken);
    }
    #endregion

    #region WolvenKit CLI

    /// <summary>
    /// Convert a .inkatlas.json file to a .inkatlas file.
    /// </summary>
    /// <param name="inkAtlasJsonPath">The full path to the .inkatlas.json file.</param>
    /// <param name="token">A cancellation token for task cancellation.</param>
    /// <param name="progress">Progress reporter to track the operation's progress.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ConvertToInkAtlasFileAsync(string inkAtlasJsonPath, CancellationToken token, IProgress<int>? progress = null)
    {
        var arguments = $"convert deserialize \"{inkAtlasJsonPath}\"";
        await ExecuteCommandAsync(arguments, token, progress);
    }

    /// <summary>
    /// Convert a .inkatlas file to a .inkatlas.json file.
    /// </summary>
    /// <param name="inkAtlasPath">The full path to the .inkatlas file.</param>
    /// <param name="token">A cancellation token for task cancellation.</param>
    /// <param name="progress">Progress reporter to track the operation's progress.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ConvertToInkAtlasJsonFileAsync(string inkAtlasPath, CancellationToken token, IProgress<int>? progress = null)
    {
        var arguments = $"convert serialize \"{inkAtlasPath}\"";
        await ExecuteCommandAsync(arguments, token, progress);
    }

    /// <summary>
    /// Import a folder of raw files to a WolvenKit faux project.
    /// </summary>
    /// <param name="sourcePath">The full path to the raw input files.</param>
    /// <param name="token">A cancellation token for task cancellation.</param>
    /// <param name="progress">Progress reporter to track the operation's progress.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ImportToWolvenKitProjectAsync(string sourcePath, CancellationToken token, IProgress<int>? progress = null)
    {
        var arguments = $"import -p \"{sourcePath}\"";
        await ExecuteCommandAsync(arguments, token, progress);
    }

    /// <summary>
    /// Pack (compress) the contents of a directory into a .archive file. This essentially "builds" the faux mod.
    /// </summary>
    /// <param name="modPath">The path to a faux mod directory.</param>
    /// <param name="outputFolder">The output folder to store the packed .archive file in.</param>
    /// <param name="token">A cancellation token for task cancellation.</param>
    /// <param name="progress">Progress reporter to track the operation's progress.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task PackArchiveAsync(string modPath, string outputFolder, CancellationToken token, IProgress<int>? progress = null)
    {
        var arguments = $"pack -p \"{modPath}\" -o \"{outputFolder}\"";
        await ExecuteCommandAsync(arguments, token, progress);
    }

    /// <summary>
    /// Unpack (extract) a .archive file to the specified output folder.
    /// </summary>
    /// <param name="archivePath">The full path to the .archive file.</param>
    /// <param name="outputFolder">The output folder to store the extracted contents in.</param>
    /// <param name="token">A cancellation token for task cancellation.</param>
    /// <param name="progress">Progress reporter to track the operation's progress.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task UnpackArchiveAsync(string archivePath, string outputFolder, CancellationToken token, IProgress<int>? progress = null)
    {
        var arguments = $"unbundle -p \"{archivePath}\" -o \"{outputFolder}\"";
        await ExecuteCommandAsync(arguments, token, progress);
    }

    /// <summary>
    /// Export an .xbm file to a .png file.
    /// </summary>
    /// <param name="modPath">The path to the folder containing the .xbm files to export.</param>
    /// <param name="outputFolder">The output folder to store the exported .png files.</param>
    /// <param name="token">A cancellation token for task cancellation.</param>
    /// <param name="progress">Progress reporter to track the operation's progress.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    public async Task ExportPngAsync(string modPath, string outputFolder, CancellationToken token, IProgress<int>? progress = null)
    {
        var arguments = $"export --uext png -p \"{modPath}\" -o \"{outputFolder}\"";
        await ExecuteCommandAsync(arguments, token, progress);
    }

    #endregion

    /// <summary>
    /// Executes a CLI command asynchronously with progress reporting and cancellation support.
    /// </summary>
    /// <param name="arguments">The arguments to run the command with.</param>
    /// <param name="token">A cancellation token for task cancellation.</param>
    /// <param name="progress">An optional progress reporter for reporting progress.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>
    private async Task ExecuteCommandAsync(string arguments, CancellationToken token, IProgress<int>? progress = null)
    {
        try
        {
            var processInfo = new ProcessStartInfo(_executablePath, arguments)
            {
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            using var process = new Process();
            process.StartInfo = processInfo;

            process.OutputDataReceived += (_, e) => OnOutputChanged(e.Data);
            process.ErrorDataReceived += (_, e) => OnErrorChanged(e.Data);

            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();

            var processTask = Task.Run(async () =>
            {
                // Process the output and report progress periodically
                int lastProgress = 0;
                while (!process.HasExited)
                {
                    // Assume the process is making progress in increments
                    lastProgress += 5;
                    progress?.Report(lastProgress);

                    if (_cancellationToken.IsCancellationRequested)
                    {
                        process.Kill();
                        _cancellationToken.ThrowIfCancellationRequested();
                    }

                    await Task.Delay(250); // Simulate progress updates
                }

                await process.WaitForExitAsync();
            });
            await processTask;
        }
        catch (Exception ex)
        {
            OnErrorChanged(ex.Message);
            AuLogger.GetCurrentLogger<Cli>("ExecuteCommand").Error(ex);
        }
    }

    private void OnOutputChanged(string? output)
    {
        if (!string.IsNullOrEmpty(output))
        {
            OutputChanged?.Invoke(this, output);
            AuLogger.GetCurrentLogger<Cli>("ExecuteCommand").Info(output);
        }
    }

    private void OnErrorChanged(string? error)
    {
        if (!string.IsNullOrEmpty(error))
        {
            ErrorChanged?.Invoke(this, error);
            AuLogger.GetCurrentLogger<Cli>("ExecuteCommand").Error(error);
        }
    }
}